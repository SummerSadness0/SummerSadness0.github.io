<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2019%2F10%2F08%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[冒泡排序普通版 123456789101112131415public class BubbleSort&#123; public static void sort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; //外层需要循环的次数，里层比较的次数 for(int i = 0; i &lt; n-1; i++)&#123; for(int j = 0; j &lt; n-1-i； j++)&#123; if(arr[ij &gt; arr[j+1])&#123; swap(arr, i, j); &#125; &#125; &#125; &#125;&#125; 改进版 123456789101112131415161718public class BubbleSort&#123; public static void sort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; //外层需要循环的次数，里层比较的次数 for(int i = 0; i &lt; n-1; i++)&#123; boolean flag = false; for(int j = 0; j &lt; n-1-i； j++)&#123; if(arr[ij &gt; arr[j+1])&#123; swap(arr, i, j); flag = true; &#125; &#125; if(!flag) break; &#125; &#125;&#125; 快速排序递归 12345678910111213141516171819202122public static void quicksort(int[] arr, int low, int high)&#123; if(arr == null || arr.length == 0) return; if(low &gt;= high) return; int target = arr[high]; int left = low-1; int right = high; int index = low; while(index &lt; right)&#123; if(arr[index] &lt; target)&#123; swap(arr, ++left,index++); &#125;else if(arr[index] &gt; target)&#123; swap(arr, --right, index); &#125;else&#123; index++; &#125; &#125; swap(arr, index, high); quicksort(arr, low, index-1); quicksort(arr, index+1, high);&#125; 非递归 得到分隔点位置后，待排序左边部分的左边界和右边界入栈, 待排序右边部分的左边界和右边界入栈,不断从栈中取出两个边界处理， 如果还有未排序部分，再入栈，出栈入栈直到栈空1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class testQuickSort &#123; public static void Quick_Sort(int[] nums)&#123; quickSort(nums, 0, nums.length-1); &#125; public static void quickSort(int[] nums, int low, int high)&#123; int par = partition(nums, low, high); Stack&lt;Integer&gt; s = new Stack&lt;&gt;(); if(par &gt; low+1)&#123; s.push(low); s.push(par-1); &#125; if(par &lt; high-1)&#123; s.push(par+1); s.push(high); &#125; while(!s.isEmpty())&#123; int end = s.pop(); int start = s.pop(); int par2 = partition(nums, start, end); if(par2 &gt; start+1)&#123; s.push(start); s.push(par2-1); &#125; if(par2 &lt; end-1)&#123; s.push(par2+1); s.push(end); &#125; &#125; &#125; public static int partition(int[] nums, int start, int end)&#123; int temp = nums[end]; int low = start-1; int high = end; int index = start; while(index &lt; high)&#123; if(nums[index] &lt; temp)&#123; swap(nums, ++low, index++); &#125;else if(nums[index] &gt; temp)&#123; swap(nums, --high, index); &#125;else&#123; index++; &#125; &#125; swap(nums, high, end); return high; &#125;&#125; 直接插入排序交换法 12345678910111213public static void insertSort(int[] arr)&#123; if(arr == null || arr.length == 0) return; for(int i = 1; i &lt; arr.length; i++)&#123; for(int j = i; j &gt; 0; j--)&#123; if(arr[j] &lt; arr[j-1])&#123; swap(arr,j,j-1); &#125;else&#123; break; &#125; &#125; &#125;&#125; 移位法 12345678910111213public static void insertSort(int[] arr)&#123; if(arr == null || arr.length == 0) return; for(int i = 1; i &lt; arr.length; i++)&#123; int temp = arr[i]; int j = i; while(j &gt; 0 &amp;&amp; arr[j-1]&gt;temp)&#123; arr[j] = arr[j-1]; j--; &#125; arr[j] = temp; &#125;&#125; 希尔排序12345678910111213141516public static void shellSort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; for(int gap = n/2; gap &gt; 0; gap /= 2)&#123; for(int i = gap; i &lt; n; i += gap)&#123; int temp = arr[i]; int j = i; while(j &gt; 0 &amp;&amp; arr[j-gap]&gt;temp)&#123; arr[j] = arr[j-gap]; j -= gap; &#125; arr[j] = temp; &#125; &#125;&#125; 选择排序12345678910111213public static void selectSort(int[] arr)&#123; if(arr == null || arr.length == 0) return; for(int i = 0; i &lt; arr.length; i++)&#123; int minIndex = i; for(int j = i; j &lt; arr.length; j++)&#123; if(arr[j] &lt; arr[minIndex]) minIndex = j; &#125; if(minIndex != i) swap(arr, minIndex, i); &#125;&#125; 归并排序123456789101112131415161718192021222324252627public static void mergeSort(int[] arr, int low, int high)&#123; if(low &gt;= high) return; int mid = low + (high-low)/2; mergeSort(arr, low, mid); mergeSort(arr, mid+1, high); merge(arr, low, high);&#125;public static void merge(int[] arr, int low, int high)&#123; int[] temp = new int[high-low+1]; int mid = low + (high - low)/2; int k = 0; int i = low; int j = mid+1; while(i &lt;= mid &amp;&amp; j &lt;= high)&#123; if(arr[i] &lt; arr[j]) temp[k++] = arr[i++]; else temp[k++] = arr[j++]; &#125; while(i &lt;= mid) temp[k++] = arr[i++]; while(j &lt;= high) temp[k++] = arr[j++]; for(int t = low; t &lt;= high; t++) arr[t] = temp[t-low];&#125; 基数排序：根据键值的每位数字来分配桶 计数排序：每个桶只存储单一键值 桶排序：每个桶存储一定范围的数值 KMP算法12345678910111213141516171819202122232425262728293031323334353637public int findStrPos(String sourceStr, String patternStr)&#123; int i = 0; int j = 0; char[] s = sourceStr.toCharArray(); char[] p = patternStr.toCharArray(); int sLen = s.length(); int pLen = p.length(); int[] next = getNextArray(patternStr); while(i &lt; sLen &amp;&amp; j &lt; pLen)&#123; if(j == -1 || s[i] == p[j])&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; &#125; if(j == pLen) return i - j; return -1;&#125;public int[] getNextArray(char[] p)&#123; int pLen = p.length; int[] next = new int[pLen]; int k = -1; int j = 0; next[0] = -1; while(j &lt; pLen - 1)&#123; if(k == -1 || p[j] == p[k])&#123; k++; j++; next[j] = k; &#125;else&#123; k = next[k]; &#125; &#125; return next;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
