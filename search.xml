<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、十进制转二进制方法一：输入一个十进制数n，每次用n除以2，把余数记下来，然后再用商去除以2……依次循环，直到商为0结束，把余数倒着依次输出即为转换后的二进制 12345678public void decimalToBinary(int n)&#123; String res = ""; while(n != 0)&#123; res = n % 2 + res; n = n / 2; &#125; System.out.println(res);&#125; 方法二：与1相与得到最低位的数字，右移一位与1相与得到次低位的数字，依次移位相与，得到每一位数字输出 12345678public void decimalToBinary(int n)&#123; String res = ""; while(n != 0)&#123; res = n &amp; 1 + res; n = n &gt;&gt;&gt; 1; &#125; System.out.println(res);&#125; 二、十进制转八进制方法一：输入一个十进制数n，每次用n除以8，把余数记下来，然后再用商去除以8……依次循环，直到商为0结束，把余数倒着依次输出即为转换后的八进制 12345678public void decimalToOctal(int n)&#123; String res = ""; while(n != 0)&#123; res = n % 8 + res; n = n / 8; &#125; System.out.println(res);&#125; 方法二：十进制17二进制为10001，我们想转换为八进制的话一般三位一读，不足三位补0，后三位001即读为1，还剩10补0后变为010，读为2，所以八进制转换为21，以此思想转为代码如下： 12345678public void decimalToOctal(int n)&#123; String res = ""; while(n != 0)&#123; res = n &amp; 7 + res; n = n &gt;&gt;&gt; 3; &#125; System.out.println(res);&#125; 三、十进制转十六进制方法一：输入一个十进制数n，每次用n除以16，把余数记下来，这里与上面不同，余数可能会超过10，所以还要有一个对应的字符映射表，然后再用商去除以16……依次循环，直到商为0结束，把余数倒着依次输出即为转换后的十六进制 123456789public void decimalToHex(int n)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n % 16] + res; res = n / 16; &#125; System.out.println(res);&#125; 方法二：十进制162二进制为10100010，我们想转换为十六进制的话一般四位一读，不足四位补0，后四位0010即读为2，还剩1010读为A，所以十六进制转换为A2，以此思想转为代码如下： 123456789public void decimalToHex(int n)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n &amp; 15] + res; res = n &gt;&gt;&gt; 4; &#125; System.out.println(res);&#125; 四、十进制转二、八、十六进制总结我的代码尽量写成了同一形式，便于发现规律。第一种方法就是常规思想，无论什么进制都可以用这种方法，对基数不断取余，再将得到的余数反转即可。第二种方法其实算是第一种的进化版，第一种方法是取余（%）和求商（/）操作，因为基数的特殊性（2，8，16都是2的幂），所以第二种方法中对应可以变为&amp;和右移&gt;&gt;&gt;的位运算操作，加快运算速度，但这种方法对转换成七进制、九进制这种就不管用了。 如果将方法封装的话可以写成如下： 方法一 123456789101112131415161718public void toBin(int n)&#123; trans(n, 2);&#125;public void toOtc(int n)&#123; trans(n, 8);&#125;public void toHex(int n)&#123; trans(n, 16);&#125;public void trans(int n, int base)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n % base] + res; n = n / base; &#125; System.out.println(res);&#125; 方法二 123456789101112131415161718public void toBin(int n)&#123; trans(n, 1, 1);&#125;public void toOtc(int n)&#123; trans(n, 7, 3);&#125;public void toHex(int n)&#123; trans(n, 15, 4);&#125;public void trans(int n, int base, int offset)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n &amp; base] + res; n = n &gt;&gt;&gt; offset; &#125; System.out.println(res);&#125; 五、二进制转十进制思想：如果二进制为10010的话就是1*2^1^+1*2^4^ 123456789101112public int binaryToDecimal(String s)&#123; int res = 0;//存储结果 int t = 0; //第几位 int i = s.length()-1; while(i &gt;= 0)&#123; if(s.charAt(i) == '1') res += (int)Math.pow(2, t); i--; t++; &#125; return res;&#125; 六、八进制转十进制思想：如果八进制为71的话就是1*8^0^+7*8^1^ 123456789101112public int octalToDecimal(String s)&#123; int res = 0; int t = 0; int i = s.length()-1; while(i &gt;= 0)&#123; int num = s.charAt(i)-'0'; res += num * (int)Math.pow(8, t); i--; t++; &#125; return res;&#125; 七、十六进制转十进制思想：与之前相同，不过要多加一个字母数字映射表 123456789101112131415161718192021222324252627282930313233343536public int hexToDecimal(String s)&#123; int res = 0; int t = 0; int i = s.length()-1; while(i &gt;= 0)&#123; char ch = s.charAt(i); int num = 0; switch(ch)&#123; case 'A': num = 10; break; case 'B': num = 11; break; case 'C': num = 12; break; case 'D': num = 13; break; case 'E': num = 14; break; case 'F': num = 15; break; default: num = ch - '0'; &#125; res += num * (int)Math.pow(16,t); i--; t++; &#125; return res;&#125; 八、二进制与八进制、十六进制这些进制可以通过十进制为桥梁，进行互转，比如说八进制要转为十六进制，那么可以先将八进制转为十进制，然后将十进制转为十六进制。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[冒泡排序思想 比较相邻两个元素，如果第一个比第二个大则交换 从左至右遍历，对每一对相邻得元素做如上比较交换操作，遍历一遍后最大的数放到最后正确位置 对除最后一个已排序的其它数重复步骤1、2，直到没有任何一对数字需要比较 代码1. 基础版123456789101112131415public class BubbleSort&#123; public static void sort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; //外层需要循环的次数，里层比较的次数 for(int i = 0; i &lt; n-1; i++)&#123; for(int j = 0; j &lt; n-1-i； j++)&#123; if(arr[ij &gt; arr[j+1])&#123; swap(arr, i, j); &#125; &#125; &#125; &#125;&#125; 2. 改进版如果某一次遍历后发现没有元素需要交换，说明所有元素已经有序，则可直接跳出循环，不再进行后序比较交换操作 1234567891011121314151617public class BubbleSort&#123; public static void sort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; for(int i = 0; i &lt; n-1; i++)&#123; boolean flag = false; for(int j = 0; j &lt; n-1-i； j++)&#123; if(arr[ij &gt; arr[j+1])&#123; swap(arr, i, j); flag = true; &#125; &#125; if(!flag) break; &#125; &#125;&#125; 复杂度分析 时间复杂度 O(n^2^) 空间复杂度 O(1) 快速排序思想代码复杂度分析直接插入排序思想代码复杂度分析希尔排序思想代码复杂度分析选择排序思想代码复杂度分析归并排序思想代码复杂度分析基数排序思想代码复杂度分析计数排序思想代码复杂度分析桶排序思想代码复杂度分析]]></content>
  </entry>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F10%2F09%2Ftest%2F</url>
    <content type="text"><![CDATA[标题1标题2标题3标题4标题5]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
