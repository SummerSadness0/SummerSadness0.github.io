<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Leetcode中组合总和系列]]></title>
    <url>%2F2019%2F10%2F16%2FLeetcode%E4%B8%AD%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[一、Leetcode77. 组合1、题目 给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。 示例: 输入: n = 4, k = 2输出:[ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 2、思路回溯算法，思路如图所示 3、代码12345678910111213141516171819class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); backtrack(n, k, 1, list); return res; &#125; public void backtrack(int n, int k, int start, List&lt;Integer&gt; list)&#123; if(k == 0)&#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for(int i = start; i &lt;= n; i++)&#123; list.add(i); backtrack(n, k-1, i+1, list); list.remove(list.size()-1); &#125; &#125;&#125; 二、Leetcode39. 组合总和1、题目 给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的数字可以无限制重复被选取。 说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。 示例 1: 输入: candidates = [2,3,6,7], target = 7,所求解集为:[ [7], [2,2,3]]示例 2: 输入: candidates = [2,3,5], target = 8,所求解集为:[ [2,2,2,2], [2,3,3], [3,5]] 2、思路回溯算法，思路如图所示 绿框部分为target=0，满足条件，将list加入结果集，红色部分为剪枝过程，target&lt;0，直接返回，不再向下递归 3、代码123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); backtrack(candidates, target, 0, list); return res; &#125; public void backtrack(int[] nums, int target, int start, List&lt;Integer&gt; list)&#123; if(target &lt; 0) return; if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for(int i = start; i &lt; nums.length; i++)&#123; list.add(nums[i]); backtrack(nums, target-nums[i],i, list); list.remove(list.size()-1); &#125; &#125;&#125; 三、Leetcode40. 组合总和 II1、题目 给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。解集不能包含重复的组合。示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]]示例 2: 输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 2、思路​ 与Leetcode39相似，区别在于39所给数组中无重复元素，元素可重复使用。而此题中数组中有重复元素且一个元素不可重复使用 去重 1234567891011图示：假设相同的数为33 [3......3333.....3(第k个3) ] 4 6 7 7 8 9 9 .... pl l+1 r既然区间[l+1, r]能够求出和为target的组合，其中包含了[l+1, r]区间所有含3的解的情况。而区间[l, r]3的个数比[l+1, r]3的个数更多，那么毫无疑问，[l, r]的解将覆盖[l+1, r]解中含有3的情况。因此if(i!=start &amp;&amp; candidates[i] == candidates[i-1]) continue;此判断语句用来去重 元素不可重复使用 下一次递归从i+1开始 3、代码1234567891011121314151617181920212223class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123; Arrays.sort(candidates); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); backtrack(candidates, target, 0, list); return res; &#125; public void backtrack(int[] candidates, int target, int start, List&lt;Integer&gt; list)&#123; if(target &lt; 0) return; if(target == 0)&#123; res.add(new ArrayList&lt;&gt;(list)); return; &#125; for(int i = start; i &lt; candidates.length; i++)&#123; if(i!=start &amp;&amp; candidates[i] == candidates[i-1]) continue; list.add(candidates[i]); backtrack(candidates, target-candidates[i],i+1, list); list.remove(list.size()-1); &#125; &#125;&#125; 四、Leetcode216. 组合总和 III1、题目 找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。 说明： 所有数字都是正整数。 解集不能包含重复的组合。 示例 1: 输入: k = 3, n = 7输出: [[1,2,4]]示例 2: 输入: k = 3, n = 9输出: [[1,2,6], [1,3,5], [2,3,4]] 2、思路 与前面两题类似，相当于所给数组为[1,2,3,4,5,6,7,8,9] 组合中不存在重复的数字，所以递归要从i+1开始 递归终止条件为list个数达到k且相加之和为n k&lt;0||n&lt;0为剪枝条件，如果满足则返回不再往下递归 3、代码123456789101112131415161718class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); backtrack(k,n,1, list); return res; &#125; public void backtrack(int k, int n, int start, List&lt;Integer&gt; list)&#123; if(k &lt; 0 || n &lt; 0) return; if(k == 0 &amp;&amp; n == 0) res.add(new ArrayList&lt;&gt;(list)); for(int i = start; i &lt;= 9; i++)&#123; list.add(i); backtrack(k-1,n-i,i+1, list); list.remove(list.size()-1); &#125; &#125;&#125; 五、Leetcode377. 组合总和 Ⅳ1、题目 给定一个由正整数组成且不存在重复数字的数组，找出和为给定目标正整数的组合的个数。 示例: nums = [1, 2, 3]target = 4 所有可能的组合为：(1, 1, 1, 1)(1, 1, 2)(1, 2, 1)(1, 3)(2, 1, 1)(2, 2)(3, 1) 请注意，顺序不同的序列被视作不同的组合。 因此输出为 7。 2、思路数据量不大时，如之前一样用回溯算法可以解决 但比如nums = [1, 2, 3],target = 35，最大递归深度达到35，会超出时间限制 一般需要具体求出组合解时用回溯法 只需要求解的个数时，首选动态规划，否则回溯复杂度高，容易超出时间限制 此题顺序不同的序列被视为不同的组合 因此状态转移方程为dp[i] = dp[i-nums[0]]+dp[i-nums[1]]+…dp[i-nums[len-1]],条件为i&gt;=nums[j];dp[0] = 1,dp[0]表示组成0，一个数都不选就可以了，所以dp[0]=1举个例子。假设nums={1,2,3}; target = 4 dp[4] = dp[4-1]+dp[4-2]+dp[4-3] = dp[3]+dp[2]+dp[1] dp[1] = dp[0] = 1;dp[2] = dp[1]+dp[0] = 2;dp[3] = dp[2]+dp[1]+dp[0] = 4;dp[4] = dp[4-1]+dp[4-2]+dp[4-3] = dp[3]+dp[2]+dp[1] = 7 3、代码1234567891011121314151617181920/*回溯*/class Solution &#123; int res = 0; public int combinationSum4(int[] nums, int target) &#123; backtrack(nums, target, 0); return res; &#125; public void backtrack(int[] nums, int target, int start)&#123; if(target &lt; 0)&#123; return; &#125; if(target == 0)&#123; res++; return; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; backtrack(nums, target-nums[i], i); &#125; &#125;&#125; 1234567891011121314151617/*动态规划*/class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; if(nums == null || nums.length == 0) return 0; int[] dp = new int[target+1]; dp[0] = 1; for(int i = 0; i &lt;= target; i++)&#123; for(int num : nums)&#123; if(i &gt;= num)&#123; dp[i] += dp[i-num]; &#125; &#125; &#125; return dp[target]; &#125;&#125; 123456789101112131415161718//顺序不同的序列被视为相同的组合//遍历nums数组，当前元素有取和不取两种情况dp[i] = dp[i]+dp[i-num]class Solution &#123; public int combinationSum4(int[] nums, int target) &#123; if(nums == null || nums.length == 0) return 0; int[] dp = new int[target+1]; dp[0] = 1; for(int num : nums)&#123; for(int i = 0; i &lt;= target; i++)&#123; if(i &gt;= num)&#123; dp[i] += dp[i-num]; &#125; &#125; &#125; return dp[target]; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode中和最长有关的题目总结]]></title>
    <url>%2F2019%2F10%2F11%2FLeetcode%E4%B8%AD%E5%92%8C%E6%9C%80%E9%95%BF%E6%9C%89%E5%85%B3%E7%9A%84%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[动态规划之零钱兑换]]></title>
    <url>%2F2019%2F10%2F10%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%8B%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、零钱兑换之最少硬币数1、题目 给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。 示例 1: 输入: coins = [1, 2, 5], amount = 11输出: 3解释: 11 = 5 + 5 + 1示例 2: 输入: coins = [2], amount = 3输出: -1 2、思路 ① 创建dp数组，dp[i]表示金额为i时所需的最少的硬币数 ②初始化dp数组，Integer.MAX_VALUE表示金额i 无法用硬币组合成，dp[0] = 0，amount=0时硬币数为0 ③第一层for循环遍历硬币，i=2代表只在第0个，第1个，第2个这三个硬币中选择硬币 ④第二层for循环进行取舍看当前硬币是取还是不取 3、代码 12345678910111213141516class Solution &#123; public int coinChange(int[] coins, int amount) &#123; if(coins == null || amount &lt; 0) return 0; int[] dp = new int[amount + 1]; Arrays.fill(dp, Integer.MAX_VALUE); dp[0] = 0; for(int i = 0; i &lt; coins.length; i++)&#123; for(int j = coins[i]; j &lt;= amount; j++)&#123; if(dp[j-coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j],dp[j-coins[i]]+1); &#125; &#125; return dp[amount]==Integer.MAX_VALUE?-1:dp[amount]; &#125;&#125; 二、零钱兑换之组合方案数1、题目 给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 示例 1: 输入: amount = 5, coins = [1, 2, 5]输出: 4解释: 有四种方式可以凑成总金额:5=55=2+2+15=2+1+1+15=1+1+1+1+1示例 2: 输入: amount = 3, coins = [2]输出: 0解释: 只用面额2的硬币不能凑成总金额3。示例 3: 输入: amount = 10, coins = [10]输出: 1 2、思路 3、代码 1234567891011121314class Solution &#123; public int change(int amount, int[] coins) &#123; if(coins == null) return 0; int[] dp = new int[amount+1]; dp[0] = 1; for(int i = 0; i &lt; coins.length; i++)&#123; for(int j = coins[i]; j &lt;= amount; j++)&#123; dp[j] = dp[j]+dp[j-coins[i]]; &#125; &#125; return dp[amount]; &#125;&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进制转换]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[一、十进制转二进制方法一：输入一个十进制数n，每次用n除以2，把余数记下来，然后再用商去除以2……依次循环，直到商为0结束，把余数倒着依次输出即为转换后的二进制 12345678public void decimalToBinary(int n)&#123; String res = ""; while(n != 0)&#123; res = n % 2 + res; n = n / 2; &#125; System.out.println(res);&#125; 方法二：与1相与得到最低位的数字，右移一位与1相与得到次低位的数字，依次移位相与，得到每一位数字输出 12345678public void decimalToBinary(int n)&#123; String res = ""; while(n != 0)&#123; res = n &amp; 1 + res; n = n &gt;&gt;&gt; 1; &#125; System.out.println(res);&#125; 二、十进制转八进制方法一：输入一个十进制数n，每次用n除以8，把余数记下来，然后再用商去除以8……依次循环，直到商为0结束，把余数倒着依次输出即为转换后的八进制 12345678public void decimalToOctal(int n)&#123; String res = ""; while(n != 0)&#123; res = n % 8 + res; n = n / 8; &#125; System.out.println(res);&#125; 方法二：十进制17二进制为10001，我们想转换为八进制的话一般三位一读，不足三位补0，后三位001即读为1，还剩10补0后变为010，读为2，所以八进制转换为21，以此思想转为代码如下： 12345678public void decimalToOctal(int n)&#123; String res = ""; while(n != 0)&#123; res = n &amp; 7 + res; n = n &gt;&gt;&gt; 3; &#125; System.out.println(res);&#125; 三、十进制转十六进制方法一：输入一个十进制数n，每次用n除以16，把余数记下来，这里与上面不同，余数可能会超过10，所以还要有一个对应的字符映射表，然后再用商去除以16……依次循环，直到商为0结束，把余数倒着依次输出即为转换后的十六进制 123456789public void decimalToHex(int n)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n % 16] + res; res = n / 16; &#125; System.out.println(res);&#125; 方法二：十进制162二进制为10100010，我们想转换为十六进制的话一般四位一读，不足四位补0，后四位0010即读为2，还剩1010读为A，所以十六进制转换为A2，以此思想转为代码如下： 123456789public void decimalToHex(int n)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n &amp; 15] + res; res = n &gt;&gt;&gt; 4; &#125; System.out.println(res);&#125; 四、十进制转二、八、十六进制总结我的代码尽量写成了同一形式，便于发现规律。第一种方法就是常规思想，无论什么进制都可以用这种方法，对基数不断取余，再将得到的余数反转即可。第二种方法其实算是第一种的进化版，第一种方法是取余（%）和求商（/）操作，因为基数的特殊性（2，8，16都是2的幂），所以第二种方法中对应可以变为&amp;和右移&gt;&gt;&gt;的位运算操作，加快运算速度，但这种方法对转换成七进制、九进制这种就不管用了。 如果将方法封装的话可以写成如下： 方法一 123456789101112131415161718public void toBin(int n)&#123; trans(n, 2);&#125;public void toOtc(int n)&#123; trans(n, 8);&#125;public void toHex(int n)&#123; trans(n, 16);&#125;public void trans(int n, int base)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n % base] + res; n = n / base; &#125; System.out.println(res);&#125; 方法二 123456789101112131415161718public void toBin(int n)&#123; trans(n, 1, 1);&#125;public void toOtc(int n)&#123; trans(n, 7, 3);&#125;public void toHex(int n)&#123; trans(n, 15, 4);&#125;public void trans(int n, int base, int offset)&#123; char[] ch = &#123;'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'&#125;; String res = ""; while(n != 0)&#123; res = ch[n &amp; base] + res; n = n &gt;&gt;&gt; offset; &#125; System.out.println(res);&#125; 五、二进制转十进制思想：如果二进制为10010的话就是$12^{1}+12^{4}$ 123456789101112public int binaryToDecimal(String s)&#123; int res = 0;//存储结果 int t = 0; //第几位 int i = s.length()-1; while(i &gt;= 0)&#123; if(s.charAt(i) == '1') res += (int)Math.pow(2, t); i--; t++; &#125; return res;&#125; 六、八进制转十进制思想：如果八进制为71的话就是$18^{0}+78^{1}$ 123456789101112public int octalToDecimal(String s)&#123; int res = 0; int t = 0; int i = s.length()-1; while(i &gt;= 0)&#123; int num = s.charAt(i)-'0'; res += num * (int)Math.pow(8, t); i--; t++; &#125; return res;&#125; 七、十六进制转十进制思想：与之前相同，不过要多加一个字母数字映射表 123456789101112131415161718192021222324252627282930313233343536public int hexToDecimal(String s)&#123; int res = 0; int t = 0; int i = s.length()-1; while(i &gt;= 0)&#123; char ch = s.charAt(i); int num = 0; switch(ch)&#123; case 'A': num = 10; break; case 'B': num = 11; break; case 'C': num = 12; break; case 'D': num = 13; break; case 'E': num = 14; break; case 'F': num = 15; break; default: num = ch - '0'; &#125; res += num * (int)Math.pow(16,t); i--; t++; &#125; return res;&#125; 八、二进制与八进制、十六进制这些进制可以通过十进制为桥梁，进行互转，比如说八进制要转为十六进制，那么可以先将八进制转为十进制，然后将十进制转为十六进制。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法总结]]></title>
    <url>%2F2019%2F10%2F09%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[冒泡排序思想 比较相邻两个元素，如果第一个比第二个大则交换 从左至右遍历，对每一对相邻得元素做如上比较交换操作，遍历一遍后最大的数放到最后正确位置 对除最后一个已排序的其它数重复步骤1、2，直到没有任何一对数字需要比较 代码1. 基础版123456789101112131415public class BubbleSort&#123; public static void sort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; //外层需要循环的次数，里层比较的次数 for(int i = 0; i &lt; n-1; i++)&#123; for(int j = 0; j &lt; n-1-i； j++)&#123; if(arr[ij &gt; arr[j+1])&#123; swap(arr, i, j); &#125; &#125; &#125; &#125;&#125; 2. 改进版如果某一次遍历后发现没有元素需要交换，说明所有元素已经有序，则可直接跳出循环，不再进行后序比较交换操作 1234567891011121314151617public class BubbleSort&#123; public static void sort(int[] arr)&#123; if(arr == null || arr.length == 0) return; int n = arr.length; for(int i = 0; i &lt; n-1; i++)&#123; boolean flag = false; for(int j = 0; j &lt; n-1-i； j++)&#123; if(arr[ij &gt; arr[j+1])&#123; swap(arr, i, j); flag = true; &#125; &#125; if(!flag) break; &#125; &#125;&#125; 复杂度分析 时间复杂度 O(n^2^) 空间复杂度 O(1) 快速排序思想代码复杂度分析直接插入排序思想代码复杂度分析希尔排序思想代码复杂度分析选择排序思想代码复杂度分析归并排序思想代码复杂度分析基数排序思想代码复杂度分析计数排序思想代码复杂度分析桶排序思想代码复杂度分析]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F10%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
